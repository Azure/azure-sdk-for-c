@startuml
' ignore these as handled outside of this diagram: MQTT_EVENT_CONNECT_REQ, MQTT_EVENT_CONNECT_RSP, MQTT_EVENT_DISCONNECT_REQ, MQTT_EVENT_DISCONNECT_RSP
' Assumptions:
' 0. Unknown events are forwarded (in their original direction, either inbound or outbound).
' 1. If RPC_CLIENT_READY_IND hasn't already been sent, RPC_CLIENT_SUB_REQ is guaranteed to respond with either RPC_CLIENT_READY_IND, or HFSM_EVENT_ERROR if the subscribe request timed out.
' 2. RPC_CLIENT_READY_IND will not be sent more than once unless the client unsubscribes or gets unsubscribed.
' 3. send_inbound, send_outbound are used to send information to the app and network respectively.

state RpcClient {
  state Idle
  Idle : <b>RPC_CLIENT_INVOKE_REQ/</b> return(HFSM_INVALID_STATE)
  Idle : <b>RPC_CLIENT_UNSUB_REQ/</b> unsubscribe()

  state Faulted
  Faulted : <b>entry/</b> send_inbound(HFSM_EVENT_ERROR)
  Faulted : <b>ANY EVENT/</b> return(HFSM_INVALID_STATE)
    
  state Subscribing
  Subscribing : <b>entry/</b> start timer
  Subscribing : <b>exit/</b> stop timer
  Subscribing : <b>RPC_CLIENT_INVOKE_REQ/</b>\n\treturn(HFSM_INVALID_STATE)
  Subscribing : <b>RPC_CLIENT_SUB_REQ/</b> return(AZ_OK) 
  
  state Ready {
    state Ready_Root
    note right of Ready_Root
      This state is not in the code, just the uml diagram for better readability.
      It refers to being in the Ready state, but not Publishing.
    end note
    state Publishing
    Publishing : <b>entry/</b> start timer
    Publishing : <b>exit/</b> stop timer
    Publishing : <b>RPC_CLIENT_INVOKE_REQ/</b> return(RPC_PUB_IN_PROGRESS)

    Ready_Root -> Publishing : <b>RPC_CLIENT_INVOKE_REQ/</b>\nsend_outbound(MQTT_PUB_REQ)
    Publishing --> Ready_Root : <b>MQTT_EVENT_PUBACK_RSP(of correct id)/</b>\nif (failure) send_inbound(RPC_CLIENT_ERROR_RSP)\n<b>HFSM_TIMEOUT/</b>\nsend_inbound(RPC_CLIENT_ERROR_RSP)
  }
  Ready : <b>MQTT_PUB_RECV_IND/</b> send_inbound_if_topic_matches()
  Ready : <b>RPC_CLIENT_SUB_REQ/</b> return(HFSM_INVALID_STATE)
  Ready : <b>MQTT_EVENT_PUBACK_RSP/</b> ignore

  [*] -> Idle
  Idle --> Subscribing : <b>RPC_CLIENT_SUB_REQ</b>/ send_outbound(MQTT_SUB_REQ)
  Idle --> Ready : <b>MQTT_PUB_RECV_IND/</b>\n send_to_ready_if_topic_matches()
  Subscribing --> Faulted : <b>HFSM_TIMEOUT</b>
  Subscribing --> Ready : <b>MQTT_EVENT_SUBACK_RSP(of correct id)/</b> send_inbound(RPC_CLIENT_READY_IND)\n<b>MQTT_PUB_RECV_IND/</b> send_to_ready_if_topic_matches()
  Ready --> Idle : <b>RPC_CLIENT_UNSUB_REQ/</b> unsubscribe()
  Subscribing --> Idle : <b>RPC_CLIENT_UNSUB_REQ/</b> unsubscribe()

}
RpcClient : <b>HFSM_EVENT_ERROR/</b> send_inbound(HFSM_EVENT_ERROR)
note bottom of RpcClient
  // Action functions
  send_to_ready_if_topic_matches(topic, event) 
  {
    if (topic == RPC_TOPIC) {
      transition_peer(Ready)
      send_inbound(RPC_CLIENT_READY_IND)
      _az_hfsm_send_event(event)
    }
  }

  send_inbound_if_topic_matches(topic) 
  {
    if (topic == RPC_TOPIC) {
      send_inbound(RPC_CLIENT_RSP)
    }
  }

  unsubscribe() 
  {
    send_outbound(MQTT_EVENT_UNSUB_REQ)
    transition_peer(Idle)
  }
end note
@enduml
